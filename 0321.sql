/*2023년 03월 21일 강의 기록 */
SELECT SUM(E.SAL) AS SUM_OF_SAL
	 , AVG(E.SAL) AS AVG_OF_SAL
 FROM EMP E;
 
SELECT DISTINCT DEPTNO
 FROM EMP;
 
SELECT DISTINCT E.EMPNO
 FROM EMP E;

SELECT DISTINCT E.DEPTNO
	 , E.SAL
	 , E.EMPNO
 FROM EMP E;
 
SELECT SUM(DISTINCT E.SAL) AS SUM_OF_DISTINCT
	 , SUM(ALL E.SAL) AS SUM_OF_ALL
	 , SUM(E.SAL) AS NOMAL_SUM
 FROM EMP E;
 

SELECT MAX(SAL) AS MAX_SAL
	 , MIN(SAL) AS MIN_SAL
	 , ROUND(MAX(SAL) / MIN(SAL), 1) AS MAX_MIN_TIMES
 FROM EMP
 WHERE DEPTNO = 10;
 

/*COUNT 집계 함수*/
SELECT COUNT(EMPNO)
	 , COUNT(COMM)
 FROM EMP;
 

SELECT COUNT(*)
 FROM EMP
 WHERE DEPTNO = 30;

SELECT COUNT(DISTINCT SAL)
 	 , COUNT(ALL SAL)
	 , COUNT(SAL)
 FROM EMP
 WHERE DEPTNO = 30;
 
SELECT COUNT(ENAME)
 FROM EMP
 WHERE COMM IS NOT NULL;
 
SELECT COUNT(ENAME)
 FROM EMP
 WHERE NVL(COMM, 0) > 0;
 
/* 부서명 UNION ALL을 이용하여 집계 */
SELECT AVG(SAL)
 	 , '10' AS DEPTNO
 FROM EMP
 WHERE DEPTNO = 10
 UNION ALL 
SELECT AVG(SAL)
 	 , '20' AS DEPTNO
 FROM EMP 
 WHERE DEPTNO = 20
 UNION ALL 
SELECT AVG(SAL)
 	 , '30' AS DEPTNO
 FROM EMP 
 WHERE DEPTNO = 30;

/*GROUP BY 키워드 사용하여 집계*/
SELECT DEPTNO
	 , JOB
 	 , AVG(SAL)
 	 , MAX(SAL)
 	 , MIN(SAL)
 	 , SUM(SAL)
 FROM EMP
 GROUP BY DEPTNO, JOB
 ORDER BY DEPTNO;

SELECT E.ENAME
 	 , S.GRADE
 	 , E.DEPTNO
 	 , E.SAL
 	 , E.JOB
 	 , E.HIREDATE
 FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT S.GRADE
	 , COUNT(E.ENAME) AS EMP_CNT --임직원 수 집계
 FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
 GROUP BY S.GRADE --grade기준으로 그룹
 ORDER BY EMP_CNT DESC; --임직원 수가 많은 그룹부터

SELECT E.ENAME
 	 , E.DEPTNO
 	 , E.JOB
 	 , S.GRADE
 	 , E.SAL
 FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
 
SELECT *
 FROM EMP E, DEPT D --내가 필요한 테이블의 별칭 지정
 WHERE E.DEPTNO = D.DEPTNO; --INNER JOIN

 
 
/*SELF-JOIN*/
SELECT E1.EMPNO AS EMP_NO
	 , E1.ENAME AS EMP_NAME
	 , E2.MGR AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.EMPNO = E2.MGR;
 

/* LEFT-JOIN 왼쪽 테이블 값을 모두 가져오고 JOIN하는 테이블에서 해당 되는 값 일부만 가져오기!
 * ORACLE SQL */
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO(+) --LEFT JOIN: E1이 LEFT TABLE로 거기에 E2를 붙이는 개념으로 쓰인 표현
 ORDER BY E1.EMPNO; 
 
 
 /*LEFT JOIN 표준 SQL*/
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1 LEFT OUTER JOIN EMP E2
 				ON (E1.MGR = E2.EMPNO)
 ORDER BY E1.EMPNO;
 
/* RIGHT JOIN 오른쪽 테이블 값을 모두 가져오고 JOIN하는 테이블에서 해당 되는 값 일부만 가져오기!
*ORACLE SQL*/
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.MGR(+) = E2.EMPNO
 ORDER BY E2.EMPNO;
 
/*RIGHT JOIN 표준 SQL*/
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1 RIGHT OUTER JOIN EMP E2
 				ON E1.MGR = E2.EMPNO
 ORDER BY E2.EMPNO;
 

/*FULL OUTER JOIN 양쪽에 상대방 컬럼에 해당하는 값이 있든 없든 다 합해서 출력 해버림
표준 SQL*/
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1 FULL OUTER JOIN EMP E2
 				ON E1.MGR = E2.EMPNO;
 				
 			
 /*FULL OUTER JOIN IN ORACLE에서는 없음
  *FULL OUTER JOIN을 오라클에서 표현하기 위하여
  *LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합할 수 있다*/
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO(+) 
UNION 			 
SELECT E1.EMPNO
	 , E1.ENAME 
	 , E1.MGR
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.MGR(+) = E2.EMPNO;
 
/*두고 두고 써먹음*/
SELECT D.DEPTNO
	 , D.DNAME
	 , E1.EMPNO
	 , E1.ENAME
	 , E1.MGR
	 , E1.SAL
	 , S.LOSAL 
	 , S.HISAL 
	 , S.GRADE 
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1
 	, DEPT D
 	, SALGRADE S
 	, EMP E2
 WHERE E1.DEPTNO(+) = D.DEPTNO
 	AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
 	AND E1.MGR = E2.EMPNO(+);
 	
 	
/*EMP, DEPT, SALGRADE, SELF-JOIN EMP
 *2씩 연관 테ㅐ이블의 일부를 오라클 SQL로 값을 출력*/
 	
SELECT D.DEPTNO
 	 , D.DNAME
 	 , E1.EMPNO
 	 , E1.ENAME
 	 , E1.MGR
 	 , E1.SAL
 FROM EMP E1
  	, DEPT D
  	, SALGRADE S
  	, EMP E2
 WHERE E1.DEPTNO (+) = D.DEPTNO
 	AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
 	AND E1.MGR = E2.EMPNO(+)
 	
 	/*부서정보 + E1, E1 + SALGRADE */
 	
 	
SELECT E1.EMPNO
	 , E1.ENAME
	 , E1.MGR
	 , E1.SAL
	 , S.LOSAL 
	 , S.HISAL 
	 , S.GRADE
 FROM EMP E1, SALGRADE S
 WHERE E1.SAL BETWEEN S.LOSAL AND S.HISAL;


/* 표준 SQL */

SELECT D.DEPTNO
	 , D.DNAME
	 , E1.EMPNO
	 , E1.ENAME
	 , E1.MGR
	 , E1.SAL
	 , S.LOSAL 
	 , S.HISAL 
	 , S.GRADE 
	 , E2.EMPNO AS MGR_NO
	 , E2.ENAME AS MGR_NAME
 FROM EMP E1 RIGHT OUTER JOIN DEPT D 
 				ON E1.DEPTNO = D.DEPTNO
 			 LEFT OUTER JOIN SALGRADE S
 			 	ON (E1.SAL >= S.LOSAL AND E1.SAL <=S.HISAL)
 			 LEFT OUTER JOIN EMP E2
 			 	ON (E1.MGR = E2.EMPNO);
 			 
 			 
/* 단일행 서브 쿼리 = 쿼리 안에 쿼리 문장을 사용
 * 
 * SELECT 쿼리의 결과는 --> 2차원 테이블에 불과
 * 
 */
 
 SELECT *
  FROM EMP
  WHERE SAL> (SELECT SAL FROM EMP
  			   WHERE ENAME = 'BLAKE');
  		
  SELECT *
   FROM EMP
   WHERE ENAME = 'BLAKE';
   
  SELECT *
   FROM EMP E, DEPT D
   WHERE E.DEPTNO = D.DEPTNO 
   		AND E.DEPTNO = 20
   	 	AND E.SAL > (SELECT AVG(SAL) FROM EMP);
   	 	 	 
  SELECT AVG(SAL)
   FROM EMP;
   
  
 /* 다중행 서브 쿼리 - 쿼리 안에 쿼리 문장을 사용
  * 
  * SELECT 쿼리의 결과는 --> 2개 이상의 값으로 된 테이블
  * 
  */
  SELECT DEPTNO, ENAME, SAL
   FROM EMP
   WHERE SAL IN(SELECT MEDIAN(SAL)
   					FROM EMP
   					GROUP BY DEPTNO);
   				
SELECT DEPTNO
	 , MAX(SAL)
 FROM EMP
 GROUP BY DEPTNO
 ORDER BY DEPTNO;

SELECT *
 FROM EMP
 WHERE SAL = ANY (SELECT SAL
 					FROM EMP 
 					WHERE DEPTNO = 30);

SELECT SAL
 FROM EMP 
 WHERE DEPTNO = 30;


SELECT *
 FROM EMP
 WHERE SAL < ANY (SELECT SAL
 					FROM EMP
 					WHERE DEPTNO = 30); 
 				
 				
SELECT *
 FROM EMP
 WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
 							FROM EMP
 							GROUP BY DEPTNO);
  
 /* FROM 절에 사용되는 서브 쿼리*/
SELECT A.ENAME
	 , A.SAL
	 , B.DNAME
	 , B.LOC
 FROM (SELECT * FROM EMP WHERE DEPTNO = 30) A
 	, (SELECT * FROM DEPT) B
 WHERE A.DEPTNO = B.DEPTNO;
 

/*WITH 절(구문) 사용 = 편리한 가상 테이블로 활용*/

WITH E AS (SELECT * FROM EMP WHERE DEPTNO = 20)
	, D AS (SELECT * FROM DEPT )
SELECT E.ENAME
	 , D.DNAME
	 , D.LOC
 FROM E, D
 WHERE E.DEPTNO = D.DEPTNO;
 

WITH E AS (SELECT * FROM EMP WHERE DEPTNO = 20)
	, D AS (SELECT * FROM DEPT )
	, S AS (SELECT * FROM SALGRADE)
SELECT E.ENAME
	 , D.DNAME
	 , E.SAL
	 , D.LOC
	 , S.GRADE
 FROM E, D, S
 WHERE E.DEPTNO = D.DEPTNO
 	AND E.SAL BETWEEN S.LOSAL AND S.HISAL;
 	
/* CREATE TABLE*/
CREATE TABLE DEPT_TABLE
	AS SELECT * FROM DEPT;

COMMIT; --TO CONFIRM IF ANY CHANGES ON DB IS VALID