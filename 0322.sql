/*03월 22일 SQL 마지막 이론 시간*/

/*CREATE TABLE*/
CREATE TABLE DEPT_TEMP
	AS(SELECT * FROM DEPT);
	
--COMMIT: TO CONFIRM IF ANY CHANGE ON DB IS VALID


/*데이터를 입력하는 양식
 * INSERT INTO 테이블명(컬럼명1, 컬럼명2,..., 컬럼명N)
 * VALUES (데이터1, 데이터2, ..., 데이터N) */

SELECT *
	FROM DEPT_TEMP DT;
	
INSERT INTO DEPT_TEMP
		   (DEPTNO
		  , DNAME
		  , LOC)
 VALUES(50
 	 , 'DATABASE'
 	 , 'SEOUL');
 	 
 	SELECT * FROM DEPT_TEMP;
 	
 --ROLLBACK;
 
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
 VALUES (60, 'WEB', NULL);
  
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
 VALUES (70, 'WEB', NULL); 

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
 VALUES (80, 'MOBILE', '');
 
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
 VALUES (90, 'METABUS', 'INCHEON');
 
CREATE TABLE EMP_TEMP AS
	SELECT * FROM EMP
	WHERE 1<>1;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM)
 VALUES ( 9999, '김보고', 'PRESIDENT', NULL, TO_DATE('2019/07/01', 'YYYY/MM/DD'), 9000, 300);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM)
 VALUES ( 9999, '김경점', 'VICE', 9999, TO_DATE('2020/03/01', 'YYYY/MM/DD'), 9500, 500);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM)
 VALUES ( 1317, '박선미', 'CEO', NULL, TO_DATE('2019/12/26', 'YYYY/MM/DD'), 9999 ,1000);

SELECT *
FROM EMP_TEMP;

SELECT E.EMPNO
	 , E.ENAME
	 , E.JOB
	 , E.MGR
	 , E.HIREDATE
	 , E.SAL
	 , E.COMM
	 , E.DEPTNO
 FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
 		AND S.GRADE = 1;
 	
SELECT *
 FROM EMP_TEMP;


 CREATE TABLE DEPT_TEMP2
 	AS (SELECT * FROM DEPT);
 
 SELECT *
  FROM DEPT_TEMP2;
 
 
 /* UPDATE... SET... */
 UPDATE DEPT_TEMP2 SET	 
 
 
 SELECT *
  FROM EMP
  WHERE ROWNUM < 3;
 
 
 UPDATE DEPT_TEMP2
 SET (DNAME, LOC) = (SELECT DNAME, LOC
 						FROM DEPT
 						WHERE DEPTNO = 40
 					)
 WHERE DEPTNO = 40;

ROLLBACK;

SELECT *
FROM DEPT_TEMP2;

COMMIT;

/*DELETE 구문으로 테이블에서 값을 제거
 * 
 * 대부분의 경우 (또는 반드시) WHERE 조건이 필요!
 * 
 * 보통의 경우, DELETE보다는  UPDATE 구문으로 상태 값을 반영
 * 
 * 예시: 근무/휴직/퇴사 등의 유형으로 값을 변경
 * 
 */

 SELECT *
  FROM EMP_TEMP2;
  
CREATE TABLE EMP_TEMP2
			AS (SELECT * FROM EMP);
			
COMMIT;

DELETE FROM EMP_TEMP2
 WHERE JOB = 'ANALYST';
 --인사팀에서 명령 실행

ROLLBACK; --사장단에서 승인 거부됨

/*
 * WHERE  조건을 좀 더 복잡하게 주고
 * DELETE 실행
 */

DELETE FROM EMP_TEMP2 --HR 개발 테스트를 위한 임시 테이블 2
 WHERE EMPNO IN (SELECT EMPNO
				 FROM EMP_TEMP2 E, SALGRADE S
				 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
				 AND S.GRADE = 3
				 AND DEPTNO = 30);
				
/*CREATE 문을 정의 : 기존에 없는 테이블 구조를 생성
 *데이터는 없고, 테이블의 컬럼과 데이터타입, 제약 조건 등의 구조를 생성
*/
				
CREATE TABLE EMP_NEW( -- 테이블명
	  EMPNO		NUMBER(4)
	, ENAME 	VARCHAR(10)
	, JOB 		VARCHAR(9)
	, MGR 		NUMBER(4)
	, HIREDATE	DATE
	, SAL 		NUMBER(7,2)
	, COMM		NUMBER(7,2)
	, DEPTNO 	NUMBER(2)
);

SELECT *
 FROM EMP
 WHERE ROWNUM <= 5;

DROP TABLE EMP_TEMP;

ALTER TABLE EMP_NEW
 ADD HP VARCHAR(20);

SELECT *
 FROM EMP_NEW;

COMMIT;
 
ALTER TABLE EMP_NEW 
 RENAME COLUMN HP TO TEL_NO;
 
ALTER TABLE EMP_NEW
 MODIFY EMPNO NUMBER(12);
 

ALTER TABLE EMP_NEW
 DROP COLUMN TEL_NO;
 
CREATE SEQUENCE SEQ_DEPTNO
	INCREMENT BY 1
	START WITH 1
	MAXVALUE 999
	MINVALUE 1
	NOCYCLE --최댓값 999에 도착하면 반복하지 않고 멈춤을 의미 
	NOCACHE; --메모리상의 시퀀스 값을 관리하는데 기본값 20이고 nocache는 원칙적으로 메모리 상에서 시퀀스를 관리하지 않습니다.
	
INSERT INTO DEPT_TEMP2 (DEPTNO, DNAME, LOC)
 VALUES (SEQ_DEPTNO.NEXTVAL, 'DATABASE', 'LONDON');

INSERT INTO DEPT_TEMP2 (DEPTNO, DNAME, LOC)
 VALUES (SEQ_DEPTNO.NEXTVAL, 'MOBILE', 'BERN');

INSERT INTO DEPT_TEMP2 (DEPTNO, DNAME, LOC)
 VALUES (SEQ_DEPTNO.NEXTVAL, 'WEB', 'PARIS');

SELECT *
FROM DEPT_TEMP2

/*제약 조건(CONSTRAINT) 지정
 * 
 * 테이블을 생성할 때, 테이블 컬럼별 제약 조건을 설정
 * 
 * 자주 사용되는 중요한 제약 조건 유형
 * NOT NULL
 * UNIQUE
 * PK
 * FK
 */

CREATE TABLE LOGIN(
 	  LOGIN_ID 		VARCHAR2(20)NOT NULL
	, LOGIN_PWD 	VARCHAR2(20)NOT NULL
	, TEL 			VARCHAR2(20)
	);

INSERT INTO LOGIN (LOGIN_ID, LOGIN_PWD, TEL)
 VALUES('TEST01', NULL, '010-7917-7197'); --NOT NULL CONSTRAINT 위배
 
INSERT INTO LOGIN (LOGIN_ID, LOGIN_PWD)
 VALUES('TEST01', 1234); --'TEL' COLUMN이 NOT NULL CONSTRAINT가 없기 때문에 INSERT 실행 됨.
 
SELECT *
 FROM LOGIN
 
/*TEL COLUMN의 중요성을 나중에 인식하고, NOT NULL 제약 조건을 설정
 */
 
ALTER TABLE LOGIN --잘못된 표현/ 실행이 안 됨.
 MODIFY TEL NOT NULL;

UPDATE LOGIN
SET TEL = '010-4301-0417'
WHERE LOGIN_ID = 'TEST01';

/*
 * 오라클 DBMS가 사용자를 위해 만들어 놓은 제약조건 설정값 테이블
 */
 
SELECT OWNER
	 , CONSRAINT_NAME
	 , CONTSTRAINT_TYPE
	 , TABLE_NAME
 FROM USER CONSTRAINITS
 WHERE  = USER_CONSTRAINTS;

SELECT *
 FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'LOGIN';

ALTER TABLE LOGIN
 MODIFY (TEL CONSTRAINT TEL_NN NOT NULL);

ALTER TABLE LOGIN 
 DROP CONSTRAINT TEL_NN;
  
ALTER TABLE LOGIN 
 MODIFY (LOG_PWD CONSTRAINT PWD_NN NOT NULL);

SELECT *
FROM LOGIN;


CREATE TABLE LOG_UNIQUE 
 ( 
		  LOG_ID 		VARCHAR2(20) UNIQUE 
		, LOG_PWD 		VARCHAR2(20) NOT NULL
		, TEL 			VARCHAR2(20)
 );

SELECT *
 FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'LOG_UNIQUE';
	
INSERT INTO LOG_UNIQUE (LOG_ID, LOG_PWD, TEL)
 VALUES( 'TEST01', 'PWD0123', '010-0000-0000');
 
INSERT INTO LOG_UNIQUE (LOG_ID, LOG_PWD, TEL)
 VALUES( 'TEST02', 'PWD12345', '010-0000-0000');

INSERT INTO LOG_UNIQUE (LOG_ID, LOG_PWD, TEL)
 VALUES( 'TEST03', 'PWD0000000', '010-0000-0000');

INSERT INTO LOG_UNIQUE (LOG_ID, LOG_PWD, TEL)
 VALUES( NULL, 'ASDFASDF', '010-0000-0000');
 
SELECT *
 FROM LOG_UNIQUE;

UPDATE LOG_UNIQUE 
 SET LOG_ID = 'TEST_ID_NEW' --사용자가 ID 변경을 요청
 WHERE LOG_ID IS NULL;
 
ALTER TABLE LOG_UNIQUE 
 MODIFY (TEL UNIQUE);
 
SELECT *
 FROM USER_CONSTRAINTS;
 
CREATE TABLE LOG_PK
(
	    LOG_ID		VARCHAR2(20) PRIMARY KEY
	  , LOG_PWD 	VARCHAR2(20) NOT NULL
	  , HHBYTELEN 	VARCHAR2(20)
);

INSERT INTO LOG_PK (LOG_ID, LOG_PWD, TEL)
 VALUES ('PK01', 'PWD01', '010-1234-5678');
 
--기존 고객의 ID와 동일한 ID 입력하는 경우 / PK 제약조건 위반
INSERT INTO LOG_PK (LOG_ID, LOG_PWD, TEL)
 VALUES ('PK01', 'PWD03', '011-1234-5678');
 
--ID를 NULL로 할 경우/PK 제약조건 위반
INSERT INTO LOG_PK (LOG_ID, LOG_PWD, TEL)
 VALUES (NULL, 'PWD02', '011-1234-5678');


SELECT *
FROM EMP_TEMP;


/* 존재하지 않는 부서번호를  EMP_TEMP 테이블에 입력을 시도*/
INSERT INTO EMP_TEMP ( EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
 VALUES (3333, '박지예','CFO', NULL, TO_DATE('2017/01/01', 'YYYY/MM/DD'), 8900, 700, 99);

--특정 직군에 해당하는 직원을 빠르게 찾기 위한 색인 지정
CREATE INDEX IDX_EMP_JOB
 ON EMP(JOB);
 
--설정한 인덱스 리스트 출력
SELECT *
 FROM USER_INDEXES
 WHERE TABLE_NAME IN ('EMP','DEPT');
 
/* VIEW : 테이블을 편리하게 사용하기 위한 목적으로 생성하는 가상 테이블*/
CREATE VIEW VW_EMP
 AS ( SELECT EMPNO, ENAME, JOB, DEPTNO
 		FROM EMP
 		WHERE DEPTNO = 10);
 	
 SELECT *
  FROM VW_EMP;

 SELECT *
  FROM USER_VIEWS
  WHERE VIEW_NAME = 'VW_EMP'; --테이블명은 대문자로 표기  
 
 --cf USER_''를 하면 오라클 현재 계정의 뷰와, 제약조건, 인덱스 등을 볼 수 있다.
 SELECT *
  FROM USER_CONSTRAINTS;
 
 SELECT *
  FROM USER_VIEWS;
 
 SELECT *
  FROM USER_INDEXES;
 
 
 /* ROWNUM 사용 : 상위 N개를 출력하기 위해 사용하며
  * 컬럼에 ROWNUM 순번을 입력하여 사용할 수 있음
  */
 
SELECT ROWNUM
 	 , E.*
 FROM EMP E
 ORDER BY SAL DESC;
 
SELECT ROWNUM
	 , E.*
 FROM (SELECT *
		 FROM EMP E
		 ORDER BY SAL DESC) E
 ORDER BY SAL DESC;
 
SELECT ROWNUM
 	 , E.*
 FROM (SELECT *
		 FROM EMP E
		 ORDER BY SAL DESC) E 
 WHERE ROWNUM <= 5;
 
/*
 * 오라클 DBMS에서 관리하는 테이블 리스트 출력
 */
SELECT *
 FROM DICT
 WHERE TABLE_NAME LIKE 'USER_%'; --% 와일드 카드
 
SELECT *
 FROM DBA_TABLES;
 
SELECT *
 FROM DBA_USERS 
 WHERE USERNAME = 'SCOTT';